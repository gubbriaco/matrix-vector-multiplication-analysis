Analizzando l'insieme delle soluzioni hardware proposte, è possibile effettuare alcune considerazioni finali riguardo l'utilizzazione delle risorse corrispondente ad ogni solution. Bisogna specificare che nel plot sotto allegato, le solution che fanno riferimento al partizionamento degli array columnIndex, values e x saranno definite, per semplicità, nella seguente maniera:
\begin{itemize}
	\item (columnIndex, values, x) $\rightarrow$ a
	\item columnIndex $\rightarrow$ b
	\item values $\rightarrow$ c
	\item x $\rightarrow$ d
\end{itemize} 
Ad esempio, la solution 10 basata sul partitioning di columnIndex, values e x verrà identificata all'interno del plot come "s10a" mentre la solution 8 basata sul partitioning di values verrà identificata all'interno del plot come "s8c".

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|c|c|c|}
		\hline
		\textbf{Solution} & \textbf{SLICE} & \textbf{LUT} & \textbf{FF} & \textbf{DSP} & \textbf{BRAM} \\
		\hline
		1 & 48 & 93 & 161 & 3 & 0 \\
		\hline
		2 & 38 & 115 & 139 & 3 & 0 \\
		\hline
		3 & 48 & 94 & 161 & 3 & 0 \\
		\hline
		4 & 83 & 186 & 292 & 3 & 0 \\
		\hline
		5 & 69 & 184 & 196 & 6 & 0 \\
		\hline
		6 &  &  &  &  & \\
		\tabitem columnIndex, values, x & 113 & 316 & 198 & 6 & 0 \\
		\tabitem columnIndex & 84 & 259 & 224 & 6 & 0 \\
		\tabitem values & 99 & 327 & 224 & 6 & 0 \\
		\tabitem x & 99 & 250 & 198 & 6 & 0 \\
		\hline
		7 & 314 & 915 & 297 & 12 & 0 \\
		\hline
		8 &  &  &  &  &  \\
		\tabitem columnIndex, values, x & 123 & 343 & 315 & 6 & 0 \\
		\tabitem columnIndex & 85 & 261 & 226 & 6 & 0 \\
		\tabitem values & 92 & 274 & 196 & 6 & 0 \\
		\tabitem x & 104 & 248 & 313 & 6 & 0 \\
		\hline
		9 & 75 & 248 & 131 & 3 & 0 \\
		\hline
		10 &  &  &  &  &  \\
		\tabitem columnIndex, values, x & 204 & 558 & 449 & 6 & 0 \\
		\tabitem columnIndex & 83 & 268 & 230 & 6 & 0 \\
		\tabitem values & 117 & 342 & 199 & 6 & 0 \\
		\tabitem x & 143 & 311 & 444 & 6 & 0 \\
		\hline
		11 &  &  &  &  &  \\
		\tabitem columnIndex, values, x & 179 & 454 & 450 & 6 & 0 \\
		\tabitem columnIndex & 90 & 267 & 227 & 6 & 0 \\
		\tabitem values & 122 & 391 & 232 & 6 & 0 \\
		\tabitem x & 143 & 311 & 444 & 6 & 0 \\
		\hline
	\end{tabular}
	\caption{HLS Conclusions Export RTL Report}
	\label{tab:hls-conclusions-export-rtl-report}
\end{table}

In particolare, è possibile notare come la solution 3 prevede la medesima utilizzazione della solution 1. Infatti, come già precedentemente esposto nella sezione corrispondente, tale solution corrisponde alla solution 1 dal momento che la direttiva di pipelining prevista nel loop1 non viene interpretata dal tool a causa dei bound non noti. Pertanto, il tool ignora tale pragma sintetizzando il circuito come se tale direttiva non fosse presente all'interno del loop1. 
\\
Inoltre, è possibile evidenziare come nella soluzione hardware 5 è prevista l'utilizzazione di 6 DSP, rispetto alle solution precedenti ad essa in cui ne erano previste 3. Questo incremento è dovuto al fatto che nella solution 5 è previsto un unrolling di fattore pari a 2. Pertanto, se nelle soluzioni base, cioè dove non era presente alcun parallelismo all'interno del loop2, era prevista un'utilizzazione di 3 DSP, allora nella soluzione 5 ne saranno previste il doppio. Analogamente, nella soluzione hardware 7 è previsto un unrolling di fattore pari a 4. Pertanto, come si può evidenziare dalla tabella sopra allegata, si ha un notevole incremento in corrispondenza delle LUT e, inoltre, l'utilizzazione delle DSP risulta essere pari a 12. Invece, per quanto riguarda la soluzione hardware 9, dove è previsto un unrolling di fattore pari a 8, l'utilizzazione di tali risorse risulta essere minore delle solution precedentemente citate. Questo è dovuto al fatto che non è stato possibile implementare la solution in questione dal momento che il tool non riusciva a garantire gli accessi in parallelo alla memoria. In particolare, dopo aver previsto ulteriori direttive di partizionamento all'interno del loop2, il tool ha evidenziato un'ulteriore problematica dovuta a ytmp che si è cercato di risolvere introducendo un pragma di pipeline all'interno del loop1. Tale ulteriore direttiva ha evidenziato i problemi anche citati nella soluzione 3 dove non è stato possibile attuare il pipelining del loop1 a causa dei bound non noti. Per tale motivo, anche nella solution 9 sono stati riscontrati i medesimi warning che hanno portato il tool a sintetizzare l'architettura al netto di unrolling di fattore pari a 8 nel loop2 e di pipelining del loop1. Nel caso in cui, il tool fosse riuscito a sintetizzare tale solution prevedendo un parallelismo di fattore pari a 8, l'utilizzazione delle DSP, secondo i risultati delle solution basate su unrolling precedentemente citate, sarebbe stata pari a 24.
\\
Inoltre, si può notare come, in corrispondenza della soluzione hardware 10 che prevede quattro solution in base al partizionamento effettuato, si ha un incremento dell'utilizzazione delle risorse rispetto alla solution 8 dove l'approccio risulta essere il medesimo tranne che per il fattore di partitioning utilizzato che nel caso del delle soluzioni 10 risulta essere il doppio. In particolare, per le soluzioni 10 è stato previsto un valore di rows e size pari al doppio di quelli previsti per le soluzioni 8. Pertanto, il numero di risorse previste risulta essere maggiore. Tanto è vero che, per la solution 10 (columnIndex, values, x) si ha un incremento di FF di circa il $43\%$, un incremento di LUT di circa il $63\%$ e un incremento di slice di circa il $66\%$. Per quanto riguarda, invece, il numero di DSP utilizzati, questo risulta essere il medesimo tra le soluzioni 10 e le soluzioni 8 dal momento che in entrambe è previsto un fattore di unrolling pari a 2. Riguardo, invece, le soluzioni 11 nelle quali è stato previsto un partizionamento di tipologia block e di fattore pari a 8, l'utilizzazione delle risorse risulta essere quasi la medesima delle soluzioni 10. In particolare, per l'attuazione di tale direttiva è stata prevista, come precedentemente citato nell'apposita sezione, la variazione del valore della variabile nnz da 8 a 16. Tale valore nelle soluzioni 10 è pari a 8 mentre nelle soluzioni 11 è pari a 16. Tanto è vero che, le variazioni di utilizzazione di risorse tra le due categorie di solution si ha principalmente in corrispondenza dei partizionamenti degli array che prevedono un dimensionamento basato sulla variabile nnz (columnIndex e values). Infatti, in corrispondenza del partizionamento dell'array x, sia nella solution 10 che nella solution 11 l'utilizzazione delle risorse è la medesima. 

\begin{filecontents}{utilization.csv}
	Solution,SLICE,LUT,FF,DSP,BRAM
	1,48,93,161,3,0
	2,38,115,139,3,0
	3,48,94,161,3,0
	4,83,186,292,3,0
	5,69,184,196,6,0
	6a,113,316,198,6,0
	6b,84,259,224,6,0
	6c,99,327,224,6,0
	6d,99,250,198,6,0
	7,314,915,297,12,0
	8a,123,343,315,6,0
	8b,85,261,226,6,0
	8c,92,274,196,6,0
	8d,104,248,313,6,0
	9,75,248,131,3,0
	10a,204,558,449,6,0
	10b,83,268,230,6,0
	10c,117,342,199,6,0
	10d,143,311,444,6,0
	11a,179,454,450,6,0
	11b,90,267,227,6,0
	11c,122,391,232,6,0
	11d,143,311,444,6,0
\end{filecontents}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			symbolic x coords={1, 2, 3, 4, 5, 6a, 6b, 6c, 6d, 7, 8a, 8b, 8c, 8d, 9, 10a, 10b, 10c, 10d, 11a, 11b, 11c, 11d},
			xtick=data,
			xlabel={Solution},
			ylabel={\#},
			xticklabel style={rotate=90, anchor=east},
			width=1\textwidth,
			height=0.4\textwidth,
			enlarge x limits=0.05,
			legend style={at={(0.5,-0.2)}, anchor=north,legend columns=-1}
			]
			\addplot table [x=Solution, y=SLICE, col sep=comma] {utilization.csv};
			\addplot table [x=Solution, y=LUT, col sep=comma] {utilization.csv};
			\addplot table [x=Solution, y=FF, col sep=comma] {utilization.csv};
			\addplot table [x=Solution, y=DSP, col sep=comma] {utilization.csv};
			\addplot table [x=Solution, y=BRAM, col sep=comma] {utilization.csv};
			\legend{SLICE, LUT, FF, DSP, BRAM}
		\end{axis}
	\end{tikzpicture}
	\caption{Utilization Export RTL Plot}
	\label{fig:utilization-export-rtl-plot}
\end{figure}
	