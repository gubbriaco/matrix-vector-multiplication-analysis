Analizzando l'insieme delle soluzioni hardware proposte, è possibile effettuare alcune considerazioni finali riguardo l'utilizzazione delle risorse corrispondente ad ogni solution. 

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|c|c|c|}
		\hline
		\textbf{Solution} & \textbf{SLICE} & \textbf{LUT} & \textbf{FF} & \textbf{DSP} & \textbf{BRAM} \\
		\hline
		1 & 48 & 93 & 161 & 3 & 0 \\
		\hline
		2 & 38 & 115 & 139 & 3 & 0 \\
		\hline
		3 & 48 & 94 & 161 & 3 & 0 \\
		\hline
		4 & 83 & 186 & 292 & 3 & 0 \\
		\hline
		5 & 69 & 184 & 196 & 6 & 0 \\
		\hline
		6 &  &  &  &  & \\
		\tabitem columnIndex, values, x & 113 & 316 & 198 & 6 & 0 \\
		\tabitem columnIndex & 84 & 259 & 224 & 6 & 0 \\
		\tabitem values & 99 & 327 & 224 & 6 & 0 \\
		\tabitem x & 99 & 250 & 198 & 6 & 0 \\
		\hline
		7 & 314 & 915 & 297 & 12 & 0 \\
		\hline
		8 &  &  &  &  &  \\
		\tabitem columnIndex, values, x & 123 & 343 & 315 & 6 & 0 \\
		\tabitem columnIndex & 85 & 261 & 226 & 6 & 0 \\
		\tabitem values & 92 & 274 & 196 & 6 & 0 \\
		\tabitem x & 104 & 248 & 313 & 6 & 0 \\
		\hline
		9 & 75 & 248 & 131 & 3 & 0 \\
		\hline
		10 &  &  &  &  &  \\
		\tabitem columnIndex, values, x & 204 & 558 & 449 & 6 & 0 \\
		\tabitem columnIndex & 83 & 268 & 230 & 6 & 0 \\
		\tabitem values & 117 & 342 & 199 & 6 & 0 \\
		\tabitem x & 143 & 311 & 444 & 6 & 0 \\
		\hline
		11 &  &  &  &  &  \\
		\tabitem columnIndex, values, x & 179 & 454 & 450 & 6 & 0 \\
		\tabitem columnIndex & 90 & 267 & 227 & 6 & 0 \\
		\tabitem values & 122 & 391 & 232 & 6 & 0 \\
		\tabitem x & 143 & 311 & 444 & 6 & 0 \\
		\hline
	\end{tabular}
	\caption{HLS Conclusions Export RTL Report}
	\label{tab:hls-conclusions-export-rtl-report}
\end{table}

In particolare, è possibile notare come la solution 3 prevede la medesima utilizzazione della solution 1. Infatti, come già precedentemente esposto nella sezione corrispondente, tale solution corrisponde alla solution 1 dal momento che la direttiva di pipelining prevista nel loop1 non viene interpretata dal tool a causa dei bound non noti. Pertanto, il tool ignora tale pragma sintetizzando il circuito come se tale direttiva non fosse presente all'interno del loop1. 
\\
Inoltre, è possibile evidenziare come nella soluzione hardware 5 è prevista l'utilizzazione di 6 DSP, rispetto alle solution precedenti ad essa in cui ne erano previste 3. Questo incremento è dovuto al fatto che nella solution 5 è previsto un unrolling di fattore pari a 2. Pertanto, se nelle soluzioni base, cioè dove non era presente alcun parallelismo all'interno del loop2, era prevista un'utilizzazione di 3 DSP, allora nella soluzione 5 ne saranno previste il doppio. Analogamente, nella soluzione hardware 7 è previsto un unrolling di fattore pari a 4. Pertanto, come si può evidenziare dalla tabella sopra allegata, si ha un notevole incremento in corrispondenza delle LUT e, inoltre, l'utilizzazione delle DSP risulta essere pari a 12. Invece, per quanto riguarda la soluzione hardware 9, dove è previsto un unrolling di fattore pari a 8, l'utilizzazione di tali risorse risulta essere minore delle solution precedentemente citate. Questo è dovuto al fatto che non è stato possibile implementare la solution in questione dal momento che il tool non riusciva a garantire gli accessi in parallelo alla memoria. In particolare, dopo aver previsto ulteriori direttive di partizionamento all'interno del loop2, il tool ha evidenziato un'ulteriore problematica dovuta a ytmp che si è cercato di risolvere introducendo un pragma di pipeline all'interno del loop1. Tale ulteriore direttiva ha evidenziato i problemi anche citati nella soluzione 3 dove non è stato possibile attuare il pipelining del loop1 a causa dei bound non noti. Per tale motivo, anche nella solution 9 sono stati riscontrati i medesimi warning che hanno portato il tool a sintetizzare l'architettura al netto di unrolling di fattore pari a 8 nel loop2 e di pipelining del loop1. Nel caso in cui, il tool fosse riuscito a sintetizzare tale solution prevedendo un parallelismo di fattore pari a 8, l'utilizzazione delle DSP, secondo i risultati delle solution basate su unrolling precedentemente citate, sarebbe stata pari a 24.
\\


\begin{filecontents}{utilization.csv}
	Solution,SLICE,LUT,FF,DSP,BRAM
	1,48,93,161,3,0
	2,38,115,139,3,0
	3,48,94,161,3,0
	4,83,186,292,3,0
	5,69,184,196,6,0
	6a,113,316,198,6,0
	6b,84,259,224,6,0
	6c,99,327,224,6,0
	6d,99,250,198,6,0
	7,314,915,297,12,0
	8a,123,343,315,6,0
	8b,85,261,226,6,0
	8c,92,274,196,6,0
	8d,104,248,313,6,0
	9,75,248,131,3,0
	10a,204,558,449,6,0
	10b,83,268,230,6,0
	10c,117,342,199,6,0
	10d,143,311,444,6,0
	11a,179,454,450,6,0
	11b,90,267,227,6,0
	11c,122,391,232,6,0
	11d,143,311,444,6,0
\end{filecontents}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			symbolic x coords={1, 2, 3, 4, 5, 6a, 6b, 6c, 6d, 7, 8a, 8b, 8c, 8d, 9, 10a, 10b, 10c, 10d, 11a, 11b, 11c, 11d},
			xtick=data,
			xlabel={Solution},
			ylabel={\#},
			xticklabel style={rotate=90, anchor=east},
			width=1\textwidth,
			height=0.7\textwidth,
			enlarge x limits=0.05,
			legend style={at={(0.5,-0.15)}, anchor=north,legend columns=-1}
			]
			\addplot table [x=Solution, y=SLICE, col sep=comma] {utilization.csv};
			\addplot table [x=Solution, y=LUT, col sep=comma] {utilization.csv};
			\addplot table [x=Solution, y=FF, col sep=comma] {utilization.csv};
			\addplot table [x=Solution, y=DSP, col sep=comma] {utilization.csv};
			\addplot table [x=Solution, y=BRAM, col sep=comma] {utilization.csv};
			\legend{SLICE, LUT, FF, DSP, BRAM}
		\end{axis}
	\end{tikzpicture}
	\caption{Utilization Export RTL Plot}
	\label{fig:utilization-export-rtl-plot}
\end{figure}
	